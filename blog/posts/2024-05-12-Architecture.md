---
layout: Post
title: 探索互联网公司技术架构的演化之路
subtitle: 从单体到微服务
author: emo
date: 2024-05-12
useHeaderImage: true
headerImage: /img/home-bg/29.jpg
headerMask: rgba(40, 57, 101, .4)
giscus: false
catalog: true
hide: false
tags:
  - Architecture
---

随着互联网行业的快速发展，互联网公司的技术架构也在不断演化和完善。从最初的单体应用到如今的微服务架构，逐步解析每个阶段所面临的问题以及如何成功过渡到下一个阶段。

<!-- more -->

## 单体架构 Monolithic Architecture
初始阶段，整个应用程序被构建为一个单一的、紧密耦合的单体应用，所有功能模块都部署在同一个代码库中。
开发简单、部署方便，但随着业务发展和规模扩大，单体架构面临着可维护性差、扩展性有限、部署复杂等问题。

### 自身优势
* 整个应用程序被构建为一个单一的、紧密耦合的单体应用，所有功能模块都部署在同一个代码库中。
* 开发简单、部署方便，适合业务发展初期，快速满足客户需求，验证业务概念，推出迭代产品

### 面临的问题
* 可扩展性差：单体应用的架构往往难以水平扩展，随着用户量的增加，单体应用可能无法满足性能需求。
* 耦合度高：单体应用中各模块之间通常紧密耦合，一处修改可能导致整个应用的重新部署，牵一发动全身。
* 技术选型受限：单体应用往往使用同一种技术栈，难以灵活选择最适合的技术解决方案。

### 部署方式

#### 单体部署
![All in One 1](/img/in-post/Evalution1.png)

* 局限性:
  * 发版时服务会暂停
  * 并发量大的时候会大量超时
  
#### 优化方案
* 引入Nginx做反向代理，解决发版时暂停服务的问题
* 引入Redis做数据缓存，提高请求处理能力

![All in One 2](/img/in-post/Evalution2.png)

* 局限性:
  * 稳定性容易受到单点故障的影响
  * 存在大量重复代码，耦合性严重
  * 系统变得庞大复杂，难以维护和更新，扩展性受限
  * 所有功能模块都打包在一起，某些功能可能需要更多资源，而其他功能却浪费资源，可能会导致资源利用率低下。

## 服务化架构 Service-Oriented Architecture
为了解决单体架构的问题，公司开始将单体应用拆分为多个独立的服务，每个服务负责一个特定的业务功能。
服务之间通过远程调用或消息队列进行通信，提高了系统的灵活性和可扩展性，但也引入了一些新的挑战，如服务间通信复杂度增加、服务治理等问题。

### 自身优势
* 服务之间的独立性和松耦合性，使得系统更容易扩展、维护和升级。
* 服务是独立的功能单元，可以被多个应用程序共享和重用，提高了开发效率和代码复用率。
* 可以根据需求对服务进行独立部署、扩展和更新，系统更加灵活和可维护。
* 不同的服务可以组合在一起创建新的应用程序，实现更多样化的功能和业务流程。
* 支持不同平台、编程语言和技术之间的互操作性，使得系统更具灵活性和可扩展性。

### 面临问题
* 高门槛，很多服务可能导致通信的协议无法进行统一
* 不适合云环境，不同的协议导致的上线以及集成都不一致导致的部署通信的问题
* 系统变得复杂，增加了开发、部署和管理的难度
* 在跨多个服务的业务流程中，事务管理可能会变得复杂，需要考虑分布式事务处理的机制
* 由于系统的复杂性，监控和调试可能会变得困难，需要建立有效的监控和日志系统来追踪问题

### 部署方式

#### RPC架构 Remote Procedure Call
生产者和消费者之间通过远程调用的方式进行通信，以实现跨网络的服务调用和数据传输
![RPC](/img/in-post/Evalution3.png)
*  服务之间的依赖性增加，一旦某个服务出现故障，可能会影响到整个系统的稳定性。
*  随着服务的迭代更新，服务版本管理变得复杂，需要考虑不同版本之间的兼容性。

#### ESB架构 Enterprise Service Bus
![ESB](/img/in-post/Evalution4.png)
* 虽然实现了水平的扩展，但是ESB却成了系统的中心
* 存在单点故障的风险，一旦ESB出现问题，整个系统可能受到影响。
* 随着服务数量的增加，ESB可能成为系统性能的瓶颈，影响系统的吞吐量和响应时间。



## 微服务架构 Microservices Architecture
![Microservices](/img/in-post/Evalution5.png)
在服务化架构的基础上演进而来，进一步将服务细分为更小的、独立部署的微服务。
每个微服务都是一个独立的进程，可以独立开发、部署、扩展和管理，服务之间通过轻量级的通信机制（如HTTP、消息队列）进行通信。
微服务架构提供了更大的灵活性和可伸缩性，使团队可以更快地开发和部署新功能，但也需要解决分布式系统带来的挑战，如服务发现、负载均衡、数据一致性等问题。

### 自身优势
* 高度可扩展： 微服务架构支持水平扩展，可以根据业务需求动态调整服务的数量和规模
* 松耦合： 微服务架构中各个服务之间松耦合，可以独立开发、部署和扩展，降低了系统的维护成本
* 技术多样性： 微服务架构支持多语言、多技术栈的混合部署，可以根据业务需求选择最适合的技术解决方案
### 面临问题
* 在跨多个服务的业务流程中，事务管理可能会变得复杂，需要考虑分布式事务处理的机制。
* 由于系统的复杂性，监控和调试可能会变得困难，需要建立有效的监控和日志系统来追踪问题。
### 通信方式

#### 同步请求响应模式
基于REST架构风格设计的API，使用HTTP协议进行通信
![Microservices](/img/in-post/Evalution6.png)

##### 优势
* 简单性：易于理解和使用
* 独立性：客户端和服务端之间的松耦合
* 可缓存性：利用HTTP缓存机制提高性能

##### 劣势
* 灵活性受限：RESTful API设计可能不够灵活，无法满足所有需求
* 安全性：需要额外的安全机制来保护API

##### 适用场景
* 适合需要简单、标准化接口的场景，如Web应用程序、移动应用程序等

##### 常用工具
Express.js、Spring Boot、Django等

#### 异步请求响应模式
基于消息队列，允许不同的服务通过发送和接收消息进行通信。消息队列提供了解耦、异步、可靠性的特性。
![Microservices](/img/in-post/Evalution7.png)

##### 优势
* 解耦：发送方和接收方之间的解耦，提高系统的灵活性和可维护性
* 异步通信：提高系统的响应速度和吞吐量
* 可靠性：消息队列通常提供消息持久化和消息重试机制，确保消息的可靠传递

##### 劣势
* 引入复杂性：需要处理消息的序列化、反序列化、消息确认等问题
* 可能引入延迟：异步通信可能导致消息处理的延迟

##### 适用场景
适合需要解耦、异步通信和可靠性的场景，如日志处理、任务队列等

##### 常用工具
RabbitMQ、Kafka、ActiveMQ、Amazon SQS等

#### 事件驱动模式
通过事件进行服务间通信，服务可以发布和订阅事件，实现松耦合和异步通信。
![Microservices](/img/in-post/Evalution8.png)

##### 优势
* 松耦合：服务之间通过事件进行通信，解耦服务之间的依赖关系
* 异步通信：提高系统的响应速度和可扩展性
* 可靠性：事件驱动架构通常提供事件持久化和重试机制

##### 劣势
* 复杂性：引入事件驱动模型可能增加系统的复杂性
* 调试困难：事件驱动系统的调试可能相对困难

##### 适用场景
适合需要松耦合、异步通信和可扩展性的场景，如实时数据处理、日志处理等
##### 常用工具
RabbitMQ、Kafka、AWS SNS/SQS等

#### 共享数据模式
可以精确地请求需要的数据，避免过度获取数据
![Microservices](/img/in-post/Evalution9.png)

##### 优势
* 灵活性：客户端可以按需获取数据，减少网络传输和数据冗余。
* 强类型：定义清晰的数据模型和查询接口。
* 自描述性：客户端可以查询API的结构和数据。

##### 劣势
* 学习曲线：有一定的学习曲线。
* 性能问题：复杂查询可能导致性能问题。

##### 适用场景
适合需要灵活、精确数据查询的场景，如复杂前端应用程序、数据聚合服务等

##### 常用工具
Apollo Server、GraphQL Yoga、Prisma等

## Serverless架构：
Serverless架构是微服务架构的延伸，强调更多的抽象和自动化，开发者无需关注服务器的管理和维护。
应用以函数为单位进行部署和运行，由云服务提供商动态管理资源，根据需求分配计算资源，使开发者能够更专注于业务逻辑的开发。

### 自身优势
* 服务负载能力极强
* 开发者无需关注运维部署相关内容，专注于业务开发
* 对线上问题的跟踪复现相对繁琐，不易调试

### 面临问题
* 数据库层级对severless的支持有限
* 服务及应用规模扩大后成本高昂
